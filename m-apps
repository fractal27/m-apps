#!/bin/python3
from sys import argv
import argparse as ap
import subprocess
import csv
import os


types = {"term","graphical"}
launch_type_to_command = {
    "term":["st"],
    "term-nonint":["bash","-c"], 
    "graphical":["sh","-c"] # just launch the program
    #you can add launch types here
}


paths_to_check = os.getenv("PATH")


def die(msg):
    print(msg)
    exit(1)


def gen_text(csv_file):
    if not os.path.isfile(csv_file):
        raise FileExistsError(f"File does not exist: {csv_file}")

    dirname, basename = os.path.split(csv_file)
    if '.' in basename:
        basename = '.'.join(basename.split(".")[:-1])

    out = os.path.join(dirname,f'{basename}.ttext')

    print(f"Writing {out} from {csv_file}")
    with open(out,"w") as text:
        with open(csv_file,newline="") as csvfile:
            spamreader = csv.reader(csvfile,delimiter=",")
            for type_, name, path in spamreader:
                text.write(os.path.join(type_,name)+"\n")

class App:
    def __init__(self, app_type:str, app_name:str, app_path:str):
        """ @param app_type type of the app, as illustrated above
                it can be 'term' or 'graphical';
            @param app_name app_name
        """
        if not isinstance(app_type,str):
            raise TypeError("Wrong type for app_type in\
                            the constructor of class App");
        if not isinstance(app_name,str):
            raise TypeError("Wrong type for app_name in\
                            the constructor of class App");
        if not isinstance(app_path,str):
            raise TypeError("Wrong type for app_path in\
                            the constructor of class App");

        self.app_type = app_type
        self.app_name = app_name
        self.app_path = app_path

    def register(self, apps_csv_path):
        """@param apps_csv_path the `apps.csv` file to add this app to.
        """
        with open(apps_csv_path,"a",newline="") as csvfile:
            spamwriter = csv.writer(csvfile, delimiter=',')
            spamwriter.writerow([self.app_type,self.app_name,self.app_path])
            gen_text(apps_csv_path)


    def launch(self,*args):
        command = launch_type_to_command.get(self.app_type,["sh","-c"])
        #print(command)
        command.append(f"{os.path.join(self.app_path,self.app_name)}{(' '+' '.join(args))if args else ''}")
        print("$ ",end="")
        for x in command:
            print(f"'{x}' ",end="")
        print('\b')
        subprocess.Popen(command)

    def delete(self, apps_csv_path):
        """@param apps_csv_path the `apps.csv` file to delete this app from.
        """
        with open(apps_csv_path,"r+",newline="") as csvfile:
            csv_lines = csvfile.readlines()
            for line in csv_lines:
                if line.split(",")[0] == self.app_name:
                    csv_lines.remove(line)
                    csvfile.writelines(csv_lines)
                    gen_text(apps_csv_path)
                    break                        
        

    def check(self):
        if self.app_path is None or self.app_name is None:
            return False
        return os.path.isfile(os.path.join(self.app_path,self.app_name))

    @classmethod
    def update_all(cls,apps_csv_path):
        with open(apps_csv_path,newline="") as csvfile:
            spamreader = csv.reader(csvfile,delimiter=",")
            for type_, name, path in spamreader:
                App(type_, name, path).update(apps_csv_path)
        gen_text(apps_csv_path)

    def update(self,apps_csv_path):
        if not os.path.isfile(apps_csv_path):
            print(f"Error: Update: '{apps_csv_path=}' does not exist")
            return False

        elif self.check():
            path_from = os.path.join(self.app_path,self.app_name)
            path_to = os.path.join(os.path.dirname(apps_csv_path),self.app_type,self.app_name)
            try:
                os.symlink(path_from, path_to)
                gen_text(apps_csv_path)
                print(f"\033[32mLink '{path_to}' created.\033[0m");
            except FileExistsError:
                print(f"\033[33mLink '{path_to}' already exists.\033[0m");


commands = {"help","register","delete","check","list","update","launch"}
usage_string: str = f"Usage: $ {argv[0]} (help|register|delete|update|check|list|launch) app-name [app-type]"

parser = ap.ArgumentParser("m-apps",usage=usage_string);
parser.add_argument("-p", "--apps-csv-path", default=None, help="Csv file to execute")
parser.add_argument("-P", "--path", type=str, nargs=1, default=None, help="If you want to specify a specific directory where it is(default: search in $PATH)")
parser.add_argument("-w", "--workdir", default=[os.path.join(os.getenv("HOME"),".local","share","apps")], help="The workdir where there are the directories for the types of files, and apps.csv.")
parser.add_argument("command", type=str, nargs=1, choices=commands, default=["help"], help="Command to execute")
parser.add_argument("name", type=str, nargs='*', default=None, help="The name on which you want to execute the command(optional when using list,help)")
args = parser.parse_args()

command: str = args.command[0]
app_type: str | None = None
opt_path: str | None = None
name: str | None = None

other_launch_args: list = []

if args.name:
    name = args.name
    if len(name) >= 2 and command == "launch":
        #print(name,name[1:],name[0])
        other_launch_args = name[1:]
        name = name[0]
    elif len(name) == 2:
        name, app_type = name
    else:
        name = name[0]
if args.path:
    opt_path = args.path[0]

workdir = args.workdir[0]
apps_csv_path = args.apps_csv_path if args.apps_csv_path else os.path.join(workdir,"apps.csv")

apps = []

with open(apps_csv_path,newline="") as csvfile:
    spamreader = csv.reader(csvfile,delimiter=",")
    for type_, name_, path_ in spamreader:
        apps.append(App(type_, name_, path_))



if command == 'help' or not command:
    die(usage_string)
elif command == 'list':
    print(f"{'type'.center(15)}|{'name'.center(15)}|    path")
    for app in apps:
        name = app.app_name
        path = f"\033[32m{app.app_path.ljust(15)}\033[0m" if app.check() else f"\033[31m{app.app_path.ljust(15)}\033[0m"
        print(f"{app.app_type.center(15)}|{name.center(15)}|    {path}")#|{service.start_exec=} | {service.stop_exec=}")
elif name is not None:
    name_present = name in [app.app_name for app in apps]
    if command == 'update' and (name_present or name == 'all'):
        print(f"Updating.")
        if name == 'all':
            App.update_all(apps_csv_path)
        else:
            for app in apps:
                app.update(apps_csv_path)
    elif command == 'register' and not name_present:
        if not app_type:
            print("ERR: Type not provided.")
            exit(1)
        print(f"Registering {name}.")
        registered = False
        if opt_path:
            if os.path.isfile(opt_path):
                App(app_type,name,opt_path).register(apps_csv_path)
            else:
                print("Invalid path")
        else:
            for path in paths_to_check.split(":"):
                print("Checking path", path);
                if os.path.isfile(os.path.join(path,name)):
                    App(app_type,name,path).register(apps_csv_path)
                    print("Registration successful")
                    registered = True
                    break
            if not registered:
                print("Invalid path")

    elif name_present:
        for app in apps:
            if app.app_name == name:
                if command == 'launch':
                    print(f"Launching {name}.")
                    app.launch(*other_launch_args)
                if command == 'delete':
                    print(f"Deleting {name}.(only on paper)")
                    app.delete(apps_csv_path)
                elif command == 'check':
                    print(f"Checking {name}: {'Valid' if app.check() else 'Invalid'}")
                break
    else:
        print("ERR: app not found:",name)


