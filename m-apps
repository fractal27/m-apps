#!/bin/python3
from sys import argv
import argparse as ap
import subprocess
import csv
import os
import platform
import json
from app import App

if platform.system() == "win32":
    default_path = os.path.join(os.getenv("USER"),"AppData","apps")
    if not os.path.exists(default_path):
        os.mkdir(default_path)
else:
    default_path = os.path.join(os.getenv("HOME"),".local","share","apps")

default_types = {"term","graphical","term-nonint"}
default_launch_type_to_command = {
    "term":["st"],
    "term-nonint":["bash","-c"], 
    "graphical":["sh","-c"] # just launch the program
    #you can add launch-type-specific commands here
}

types = default_types
launch_type_to_command = default_launch_type_to_command


if os.path.exists(config_path := os.path.join(default_path,"config.jsonc")):
    json_config = json.load(open(config_path,'r'))
    types = set()

    launch_type_to_command = json_config.get("commands", None)
    if launch_type_to_command is None:
        launch_type_to_command = default_launch_type_to_command
    else:
        assert(isinstance(launch_type_to_command, dict), "Types in config.py must be a dict")
        for launchtype in launch_type_to_command:
            assert(isinstance(launchtype, str),
                   "config.json: Launch type must be a string when specifiying \"ltype\": [ \"command...\" ]")
            assert(isinstance(launch_type_to_command[launchtype], list),
                   "config.json: Launch type's value(command) must be a list when specifiying \"ltype\": [ \"command...\" ]")
            types.add(launchtype)
            for x in launch_type_to_command[launchtype]:
                assert(isinstance(x, str),
                   "config.json: Command list's arguments must all be strings.")

paths_to_check = os.getenv("PATH")



commands = {"help","register","delete","check","list","update","launch"}
usage_string: str = f"Usage: $ {argv[0]} (help|register|delete|update|check|list|launch) app-name [app-type]"

parser = ap.ArgumentParser("m-apps",usage=usage_string)
parser.add_argument("-p", "--apps-csv-path", default=None, help="Csv file to execute")
parser.add_argument("-P", "--path", type=str, nargs=1, default=None, help="If you want to specify a specific directory where it is(default: search in $PATH)")
parser.add_argument("-w", "--workdir", default=[default_path], help="The workdir where there are the directories for the types of files, and apps.csv.")
parser.add_argument("command", type=str, nargs=1, choices=commands, default=["help"], help="Command to execute")
parser.add_argument("name", type=str, nargs='*', default=None, help="The name on which you want to execute the command(optional when using list,help)")
args = parser.parse_args()

command: str = args.command[0]
app_type: str | None = None
opt_path: str | None = None
name: str | None = None

other_launch_args: list = []

if args.name:
    name = args.name
    if len(name) >= 2 and command == "launch":
        #print(name,name[1:],name[0])
        other_launch_args = name[1:]
        name = name[0]
    elif len(name) == 2:
        name, app_type = name
    else:
        name = name[0]
if args.path:
    opt_path = args.path[0]

workdir = args.workdir[0]
apps_csv_path = args.apps_csv_path if args.apps_csv_path else os.path.join(workdir,"apps.csv")
print("csv_path:",apps_csv_path)
apps = []

try:

    if os.stat(apps_csv_path).st_size != 0:
        with open(apps_csv_path,"r",newline="") as csvfile:
            spamreader = csv.reader(csvfile,delimiter=",")
            for type_, name_, path_ in spamreader:
                apps.append(App(type_, name_, path_, apps_csv_path))
except FileNotFoundError:
    print("File was not found, trying to create it.")
    open(apps_csv_path,"w").write("")


if command == 'help' or not command:
    die(usage_string)
elif command == 'list':
    print(f"{'type'.center(15)}|{'name'.center(15)}|    path")
    for app in apps:
        name = app.app_name
        path = f"\033[32m{app.app_path.ljust(15)}\033[0m" if app.check() else f"\033[31m{app.app_path.ljust(15)}\033[0m"
        print(f"{app.app_type.center(15)}|{name.center(15)}|    {path}")#|{service.start_exec=} | {service.stop_exec=}")
elif name is not None:
    name_present = name in [app.app_name for app in apps]
    if name == 'all':
        if command == 'delete':
            print(f"Deleting all.")
            if(input("Are you sure you want to delete all the registered apps(on paper)? \n(NOTE:This action is irreversible)[y/N] ")
               .lower().startswith('y')):
                App.delete_all(apps_csv_path)
        elif command == 'update':
            print(f"Updating.")
            App.update_all(apps_csv_path)
        exit(0)
    elif command == 'register' and not name_present:
        if not app_type:
            print("ERR: Type not provided.")
            exit(1)
        print(f"Registering {name}.")
        registered = False
        if opt_path:
            if os.path.isfile(os.path.join(opt_path,name)):
                print("trying to register path")
                App(app_type,name,opt_path,apps_csv_path).register()
            else:
                print(f"Invalid path: {opt_path}")
        else:
            for path in paths_to_check.split(":"):
                print("Checking path", path)
                if os.path.isfile(os.path.join(path,name)):
                    App(app_type,name,path,apps_csv_path).register()
                    print("Registration successful")
                    registered = True
                    break
            if not registered:
                print("Invalid path")

    elif name_present:
        for app in apps:
            if app.app_name == name:
                if command == 'update':
                    app.update(apps_csv_path)
                if command == 'launch':
                    print(f"Launching {name}.")
                    app.launch(*other_launch_args)
                if command == 'delete':
                    print(f"Deleting {name}.(only on paper)")
                    app.delete(apps_csv_path)
                elif command == 'check':
                    print(f"Checking {name}: {'Valid' if app.check() else 'Invalid'}")
                break
    else:
        print("ERR: app not found:",name)


